{
  "hash": "f98e6f1d83f3cf3d0fceb5d6cefd80b3",
  "result": {
    "markdown": "---\ntitle: \"Daten importieren: Teil 2\"\ndescription: Mehrere Datensätze programmatisch bearbeiten.\ndate: \"2023-03-20\"\nauthor:\n  - name: Andrew Ellis\n    url: https://github.com/awellis\n    affiliation: Kognitive Psychologie, Wahrnehmung und Methodenlehre, Universität Bern \n    affiliation-url: https://www.kog.psy.unibe.ch\n    orcid: 0000-0002-2788-936X\nlicense: CC BY\ncitation: true\nbibliography: ../../bibliography.bib\nformat:\n    html:\n        toc: true\n        code-link: true\nexecute: \n  cache: false\n---\n\n\n\n\n:::{.callout-tip collapse=\"false\"}\n## Lernziele\n\nIn der heutigen Sitzung lernen wir:\n\n- Arbeitsschritte automatisieren: mehrere Datensätze automatisch importieren\n- Mit ChatGPT Code verstehen\n:::\n\n\n:::{.callout-caution collapse=\"true\"}\n## Datacamp\n- Falls Sie eine Einführung in Programmierkonzepte (Conditionals and Control Flow, Functions, Loops) benötigen, empfehlen wir Ihnen den Datacamp Kurs [Intermediate R](https://app.datacamp.com/learn/courses/intermediate-r).\n:::\n\n\n# Mehrere Datensätze bearbeiten\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.0     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.1     ✔ tibble    3.1.8\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n:::\n\n\nMeist werden Daten für jede Versuchsperson einzeln abgespeichert. Um nicht jeden Datensatz einzeln einlesen zu müssen können wir Schleifen (loops) und Funktionen nutzen. Schleifen und Funktionen sind immer extrem zeitsparend, wenn ein Prozess wiederholt werden muss. Dies kommt in der Verarbeitung grosser Datensätze häufig vor. Zudem werden so Tippfehler vermieden, die häufig passieren, wenn man dreissig Mal dasselbe schreiben muss.\n\nNun werden wir dasselbe wie im Teil 1 machen; dort haben wir ein `csv` File importiert, und dessen Variablen ausgewählt und umbenannt. Dieses Mal wollen wir aber alle `.csv` Files laden, die  in einem Ordner gespeichert sind.\n\n<aside>\nIn Ihrem Rstudio Projekt sind die Files im Ordner `data` gespeichert.\n</aside>\n\n## Alle Files in einem Ordner auflisten\n\nZuerst erstellen wir mit `list.files()` eine Liste aller `.csv` Files im Ordner `data`. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatadir <- \"data\"\n\ncsv_files <- datadir |>\n    list.files(pattern = \"csv\", full.names = TRUE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncsv_files\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"data/JH_rdk-discrimination_2022_Mar_07_1403.csv\"   \n[2] \"data/NS_rdk-discrimination_2022_Mar_07_1331.csv\"   \n[3] \"data/rh_rdk-discrimination_2022_Mar_02_1105.csv\"   \n[4] \"data/sb_rdk-discrimination_2022_Mar_06_0746.csv\"   \n[5] \"data/SS91_rdk-discrimination_2022_Mar_06_0953.csv\" \n[6] \"data/VP1_rdk-discrimination_2022_Mar_07_1237.csv\"  \n[7] \"data/VP2_rdk-discrimination_2022_Mar_07_1302.csv\"  \n[8] \"data/VPN01_rdk-discrimination_2022_Mar_01_2142.csv\"\n[9] \"data/VPN02_rdk-discrimination_2022_Mar_01_2208.csv\"\n```\n:::\n:::\n\n\n`csv_files` enthält nun die \"Pfade\" zu allen `.csv` Files im Ordner `data`. Diese Pfade können nun einzeln and `read_csv()` übergeben werden.\n\n\n## Mit `for`-Loop\n\nZuerst brauchen wir eine Liste, in die wir die Daten einlesen können. Wir erstellen eine Liste mit der Länge der Anzahl Files, die wir haben.\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_list <- vector(\"list\", length(csv_files))\n```\n:::\n\n\nNun können wir entweder über die Elemente der Liste iterieren, oder über die Indizes. Wir wählen letzteres, da wir die Indizes später für die Zuweisung der Daten verwenden können.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in seq_along(csv_files)) {\n            df <- read_csv(csv_files[i])\n            data_list[[i]] <- df\n}\n```\n:::\n\n\n\nDas Resultat ist eine Liste, in deren Elementen die neun `csv` Files gepesichert sind.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(data_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 9\n```\n:::\n:::\n\n\nDiese wollen wir nun zu einem Dataframe zusammenfügen. Dazu können wir `do.call()` verwenden. `do.call()` nimmt eine Funktion und eine Liste als Argumente. Die Liste werden wiederum als Argumente der Funktion verwendet.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_loop <- do.call(rbind, data_list)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(data_loop)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 40\n  cue   direct…¹ pract…² pract…³ pract…⁴ pract…⁵ main_…⁶ main_…⁷ main_…⁸ main_…⁹\n  <chr> <chr>      <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>\n1 none  right          0       0       0       5      NA      NA      NA      NA\n2 left  right          0       1       1       2      NA      NA      NA      NA\n3 right right          0       2       2       1      NA      NA      NA      NA\n4 left  left           0       3       3       0      NA      NA      NA      NA\n5 none  left           0       4       4       4      NA      NA      NA      NA\n6 right left           0       5       5       3      NA      NA      NA      NA\n# … with 30 more variables: static_isi.started <dbl>, static_isi.stopped <dbl>,\n#   fixation_pre.started <dbl>, fixation_pre.stopped <chr>,\n#   image.started <dbl>, image.stopped <chr>, fixation_post.started <dbl>,\n#   fixation_post.stopped <chr>, dots_background.started <dbl>,\n#   dots_background.stopped <chr>, dots_stimulus.started <dbl>,\n#   dots_stimulus.stopped <chr>, dots_keyboard_response.keys <chr>,\n#   dots_keyboard_response.started <dbl>, …\n```\n:::\n:::\n\n\n## Mit `map` und `list_rbind`\n\nDasselbe können wir auch mit `map()` machen. Da auch hier der Output eine Liste ist, müssen wir diese auch zu einem Dataframe zusammenfügen. Dazu können wir `list_rbind()` verwenden.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- csv_files |> \n    map(read_csv) |>\n    list_rbind()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndata |>\n  slice_head(n = 20)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 20 × 40\n   cue   direc…¹ pract…² pract…³ pract…⁴ pract…⁵ main_…⁶ main_…⁷ main_…⁸ main_…⁹\n   <chr> <chr>     <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>\n 1 none  right         0       0       0       5      NA      NA      NA      NA\n 2 left  right         0       1       1       2      NA      NA      NA      NA\n 3 right right         0       2       2       1      NA      NA      NA      NA\n 4 left  left          0       3       3       0      NA      NA      NA      NA\n 5 none  left          0       4       4       4      NA      NA      NA      NA\n 6 right left          0       5       5       3      NA      NA      NA      NA\n 7 <NA>  <NA>         NA      NA      NA      NA      NA      NA      NA      NA\n 8 right right        NA      NA      NA      NA       0       0       0      18\n 9 right right        NA      NA      NA      NA       0       1       1      31\n10 none  right        NA      NA      NA      NA       0       2       2      66\n11 none  right        NA      NA      NA      NA       0       3       3      75\n12 left  left         NA      NA      NA      NA       0       4       4      13\n13 none  right        NA      NA      NA      NA       0       5       5      62\n14 none  left         NA      NA      NA      NA       0       6       6      41\n15 left  left         NA      NA      NA      NA       0       7       7      15\n16 left  right        NA      NA      NA      NA       0       8       8      32\n17 none  right        NA      NA      NA      NA       0       9       9      68\n18 none  left         NA      NA      NA      NA       0      10      10      40\n19 left  left         NA      NA      NA      NA       0      11      11       1\n20 left  left         NA      NA      NA      NA       0      12      12       3\n# … with 30 more variables: static_isi.started <dbl>, static_isi.stopped <dbl>,\n#   fixation_pre.started <dbl>, fixation_pre.stopped <chr>,\n#   image.started <dbl>, image.stopped <chr>, fixation_post.started <dbl>,\n#   fixation_post.stopped <chr>, dots_background.started <dbl>,\n#   dots_background.stopped <chr>, dots_stimulus.started <dbl>,\n#   dots_stimulus.stopped <chr>, dots_keyboard_response.keys <chr>,\n#   dots_keyboard_response.started <dbl>, …\n```\n:::\n:::\n\n\n\nNun können wir wie in Teil 1 die Practice Trials entfernen.\n\n::: {.cell}\n\n```{.r .cell-code}\ndata  <- data |>  \n        filter(!is.na(main_blocks_loop.thisN)) |>\n        select(-contains(\"practice_block_loop\"))\n```\n:::\n\n\n\n## Variablen auswählen und umbennen\n\nWir eliminieren die Variablen, die wir nicht brauchen (ISI, Fixationskreuz, Zeitangaben der Bilder, etc.).\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- data |>\n    select(-contains(\"static\"),\n           -contains(\"fixation\"),\n           -contains(\"image\"),\n           -contains(\"instruction\"),\n           -contains(\"feedback\"))\n```\n:::\n\n\nZum Schluss geben wir den Variablen, die wir behalten, noch deskriptivere Namen.\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- data |>\n    select(trial = main_blocks_loop.thisN,\n           ID = Pseudonym,\n           cue,\n           direction,\n           response = dots_keyboard_response.keys,\n           rt = dots_keyboard_response.rt)\n```\n:::\n\n\n## Neue Variablen definieren\n\n\nEine Antwort ist korrekt, wenn die gewählte Richtung der Richtung des Dot-Stimulus entspricht. Zuvor definieren wir zwei Variablen: `choice` besteht aus den Angaben \"right\" und \"left\", `response` ist eine numerische Version davon (0 = \"left\", 1 = \"right\").\n\n### Korrekte Antworten\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- data |>\n    mutate(choice = if_else(response == \"j\", \"right\", \"left\"),\n           response = if_else(choice == \"right\", 1, 0))\n```\n:::\n\n\n`correct` ist `TRUE` wenn `choice == direction`, `FALSE` wenn nicht. Wir konvertieren diese logische Variable mit `as.numeric()` in eine numerische Variable. `as.numeric()` konvertiert `TRUE` in 1 und `FALSE` in 0.\n\n\n:::{.callout-tip}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.numeric(c(TRUE, FALSE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 0\n```\n:::\n:::\n\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- data |>\n    mutate(correct = as.numeric(choice == direction))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1,440\nColumns: 8\n$ trial     <dbl> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17…\n$ ID        <chr> \"JH\", \"JH\", \"JH\", \"JH\", \"JH\", \"JH\", \"JH\", \"JH\", \"JH\", \"JH\", …\n$ cue       <chr> \"right\", \"right\", \"none\", \"none\", \"left\", \"none\", \"none\", \"l…\n$ direction <chr> \"right\", \"right\", \"right\", \"right\", \"left\", \"right\", \"left\",…\n$ response  <dbl> 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, …\n$ rt        <dbl> 0.7136441, 0.6271285, 0.6703410, 0.5738488, 0.8405913, 0.667…\n$ choice    <chr> \"right\", \"right\", \"left\", \"right\", \"right\", \"right\", \"right\"…\n$ correct   <dbl> 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, …\n```\n:::\n:::\n\n\nWir schauen uns die ersten 20 Zeilen an.\n\n::: {.cell}\n\n```{.r .cell-code}\ndata |> \n  slice_head(n = 20)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 20 × 8\n   trial ID    cue   direction response    rt choice correct\n   <dbl> <chr> <chr> <chr>        <dbl> <dbl> <chr>    <dbl>\n 1     0 JH    right right            1 0.714 right        1\n 2     1 JH    right right            1 0.627 right        1\n 3     2 JH    none  right            0 0.670 left         0\n 4     3 JH    none  right            1 0.574 right        1\n 5     4 JH    left  left             1 0.841 right        0\n 6     5 JH    none  right            1 0.668 right        1\n 7     6 JH    none  left             1 1.12  right        0\n 8     7 JH    left  left             0 0.640 left         1\n 9     8 JH    left  right            0 1.13  left         0\n10     9 JH    none  right            1 1.03  right        1\n11    10 JH    none  left             0 1.35  left         1\n12    11 JH    left  left             0 0.688 left         1\n13    12 JH    left  left             0 0.721 left         1\n14    13 JH    none  left             0 0.655 left         1\n15    14 JH    right right            1 1.02  right        1\n16    15 JH    none  right            1 1.12  right        1\n17    16 JH    left  left             0 1.08  left         1\n18    17 JH    right left             0 0.643 left         1\n19    18 JH    right right            1 0.716 right        1\n20    19 JH    left  left             0 0.578 left         1\n```\n:::\n:::\n\n\n### Cue-Bedingungsvariable\n\n\nNun brauchen wir eine Variable, die angibt, ob die Bedingung \"neutral\", \"valid\" oder \"invalid\" ist. Wir erstellen eine neue Variable `condition` und füllen sie mit `case_when()` mit den Werten \"neutral\", \"valid\" oder \"invalid\". `case_when()` erlaubt, mehrere `if_else()`-Bedingungen zu kombinieren. So wird hier der Variablen `condition` der Wert `neutral` zugewiesen, wenn `cue == \"none\"` ist. Falls `cue == direction` ist, wird der Wert `valid` zugewiesen. Falls `cue != direction` ist, wird der Wert `invalid` zugewiesen.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- data |>\n    mutate(condition = case_when(cue == \"none\" ~ \"neutral\",\n                                 cue == direction ~ \"valid\",\n                                 cue != direction ~ \"invalid\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndata |> \n  slice_head(n = 20)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 20 × 9\n   trial ID    cue   direction response    rt choice correct condition\n   <dbl> <chr> <chr> <chr>        <dbl> <dbl> <chr>    <dbl> <chr>    \n 1     0 JH    right right            1 0.714 right        1 valid    \n 2     1 JH    right right            1 0.627 right        1 valid    \n 3     2 JH    none  right            0 0.670 left         0 neutral  \n 4     3 JH    none  right            1 0.574 right        1 neutral  \n 5     4 JH    left  left             1 0.841 right        0 valid    \n 6     5 JH    none  right            1 0.668 right        1 neutral  \n 7     6 JH    none  left             1 1.12  right        0 neutral  \n 8     7 JH    left  left             0 0.640 left         1 valid    \n 9     8 JH    left  right            0 1.13  left         0 invalid  \n10     9 JH    none  right            1 1.03  right        1 neutral  \n11    10 JH    none  left             0 1.35  left         1 neutral  \n12    11 JH    left  left             0 0.688 left         1 valid    \n13    12 JH    left  left             0 0.721 left         1 valid    \n14    13 JH    none  left             0 0.655 left         1 neutral  \n15    14 JH    right right            1 1.02  right        1 valid    \n16    15 JH    none  right            1 1.12  right        1 neutral  \n17    16 JH    left  left             0 1.08  left         1 valid    \n18    17 JH    right left             0 0.643 left         1 invalid  \n19    18 JH    right right            1 0.716 right        1 valid    \n20    19 JH    left  left             0 0.578 left         1 valid    \n```\n:::\n:::\n\n\n### Daten als CSV speichern\n\nAn dieser Stelle speichern wir den neu kreierten Datensatz als `.csv` File in einen Ordner names `data_clean`. Somit können wir zu einem späteren Zeitpunkt die Daten einfach importieren, ohne die ganzen Schritte wiederholen zu müssen.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata |> write_csv(file = \"data_clean/rdkdata.csv\")\n```\n:::\n\n\n\n## Gruppierungsvariablen \n\nAlle Gruppierungsvariablen sollten nun zu Faktoren konvertiert werden. \n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- data |>\n    mutate(across(where(is.character), as_factor))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1,440\nColumns: 9\n$ trial     <dbl> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17…\n$ ID        <fct> JH, JH, JH, JH, JH, JH, JH, JH, JH, JH, JH, JH, JH, JH, JH, …\n$ cue       <fct> right, right, none, none, left, none, none, left, left, none…\n$ direction <fct> right, right, right, right, left, right, left, left, right, …\n$ response  <dbl> 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, …\n$ rt        <dbl> 0.7136441, 0.6271285, 0.6703410, 0.5738488, 0.8405913, 0.667…\n$ choice    <fct> right, right, left, right, right, right, right, left, left, …\n$ correct   <dbl> 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, …\n$ condition <fct> valid, valid, neutral, neutral, valid, neutral, neutral, val…\n```\n:::\n:::\n\n\n\n## Daten überprüfen\n\nWir überprüfen, ob die Daten korrekt sind. Dazu schauen wir uns die Anzahl der Trials pro Person und pro Bedingung an. Sie können mehr Zeilen anzeigen, indem sie `n = `  in der Funktion `slice_head()` ändern.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata |> \n  group_by(ID, condition) |>\n  summarise(n_trials = n()) |>\n  slice_head(n = 20)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'ID'. You can override using the `.groups`\nargument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 27 × 3\n# Groups:   ID [9]\n   ID    condition n_trials\n   <fct> <fct>        <int>\n 1 JH    valid           64\n 2 JH    neutral         80\n 3 JH    invalid         16\n 4 NS    valid           64\n 5 NS    neutral         80\n 6 NS    invalid         16\n 7 rh    valid           64\n 8 rh    neutral         80\n 9 rh    invalid         16\n10 sb    valid           64\n# … with 17 more rows\n```\n:::\n:::\n\n    \n\n## Accuracy pro Person/Bedingung\n\nNun berechnen wir pro Person und pro Bedingung die Anzahl der korrekten Antworten und die Accuracy. Die Accuracy ist die Anzahl der korrekten Antworten geteilt durch die Anzahl der Trials.\n\n\n::: {.cell}\n\n```{.r .cell-code}\naccuracy <- data |>\n    group_by(ID, condition) |>\n    summarise(N = n(),\n              ncorrect = sum(correct),\n              accuracy = mean(correct))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'ID'. You can override using the `.groups`\nargument.\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\naccuracy\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 27 × 5\n# Groups:   ID [9]\n   ID    condition     N ncorrect accuracy\n   <fct> <fct>     <int>    <dbl>    <dbl>\n 1 JH    valid        64       60    0.938\n 2 JH    neutral      80       66    0.825\n 3 JH    invalid      16       13    0.812\n 4 NS    valid        64       58    0.906\n 5 NS    neutral      80       56    0.7  \n 6 NS    invalid      16       11    0.688\n 7 rh    valid        64       61    0.953\n 8 rh    neutral      80       64    0.8  \n 9 rh    invalid      16        2    0.125\n10 sb    valid        64       62    0.969\n# … with 17 more rows\n```\n:::\n:::\n\n\n## Visualisieren\n\n\n::: {.cell}\n\n```{.r .cell-code}\naccuracy |> \n  ggplot(aes(x = condition, y = accuracy, fill = condition)) +\n  geom_col() +\n  geom_line(aes(group = ID), linewidth = 2) +\n  geom_point(size = 4) +\n  scale_fill_manual(values = c(invalid = \"#9E0142\",\n                    neutral = \"#C4C4B7\",\n                    valid = \"#2EC762\")) +\n  labs(x = \"Cue\",\n      y = \"Proportion correct\",\n      title = \"Accuracy per person/condition\") +\n  facet_wrap(~ID) +\n  theme_linedraw(base_size = 28) +\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](importing_data-2_files/figure-html/unnamed-chunk-28-1.png){width=1440}\n:::\n:::\n",
    "supporting": [
      "importing_data-2_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}