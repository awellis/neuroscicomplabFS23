{
  "hash": "408febff660bbdc9dc28d11769ddef36",
  "result": {
    "markdown": "---\ntitle: \"SDT anwenden\"\ndescription: |\n  Bias im RDK Experiment untersuchen.\ndate: \"2022-05-01\"\nauthor:\n  - name: Andrew Ellis\n    url: https://github.com/awellis\n    affiliation: Kognitive Psychologie, Wahrnehmung und Methodenlehre, UniversitÃ¤t Bern \n    affiliation-url: https://www.kog.psy.unibe.ch\n    orcid: 0000-0002-2788-936X\nlicense: CC BY\ncitation: true\nbibliography: ../../bibliography.bib\nformat:\n    html:\n        toc: true\n        code-link: true\nexecute: \n  cache: false\ncode-annotations: select\n---\n\n\n\n:::{.callout-tip collapse=\"false\"}\n## Lernziele\n\nIn der heutigen Sitzung lernen wir:\n\n- SDT auf einen Datensatz mit mehreren Bedingungen anwenden.\n- SensitivitÃ¤t $d'$ und Bias $c$ grafisch darstellen und zwischen 'within'-Bedingungen vergleichen.\n:::\n\n:::{.callout-tip}\n## Wichtig\n\nðŸ‘‰ [Daten fÃ¼r diese Sitzung herunterladen](../../downloadable_files/rdkdata_clean.csv)\n:::\n\n\n## Daten importieren\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nâ”€â”€ Attaching core tidyverse packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse 2.0.0 â”€â”€\nâœ” dplyr     1.1.2     âœ” readr     2.1.4\nâœ” forcats   1.0.0     âœ” stringr   1.5.0\nâœ” ggplot2   3.4.2     âœ” tibble    3.2.1\nâœ” lubridate 1.9.2     âœ” tidyr     1.3.0\nâœ” purrr     1.0.1     \nâ”€â”€ Conflicts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse_conflicts() â”€â”€\nâœ– dplyr::filter() masks stats::filter()\nâœ– dplyr::lag()    masks stats::lag()\nâ„¹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n:::\n\n\nWir importieren die Daten aus dem RDK Experiment.\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- read_csv(\"data/rdkdata_clean.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 7163 Columns: 11\nâ”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nDelimiter: \",\"\nchr (4): condition, cue, direction, choice\ndbl (7): id, trial_all, block, trial_inblock, response, rt, correct\n\nâ„¹ Use `spec()` to retrieve the full column specification for this data.\nâ„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n:::\n\n\nZur Sicherheit schauen wir uns die ersten 10 Zeilen an.\n\n::: {.cell}\n\n```{.r .cell-code}\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7,163 Ã— 11\n      id trial_all block trial_inblock condition cue   direction choice response\n   <dbl>     <dbl> <dbl>         <dbl> <chr>     <chr> <chr>     <chr>     <dbl>\n 1   511         0     0             0 neutral   none  right     right         1\n 2   511         1     0             1 neutral   none  left      left          0\n 3   511         2     0             2 invalid   right left      left          0\n 4   511         3     0             3 invalid   left  right     right         1\n 5   511         4     0             4 valid     right right     right         1\n 6   511         5     0             5 valid     right right     left          0\n 7   511         6     0             6 valid     right right     left          0\n 8   511         7     0             7 valid     right right     right         1\n 9   511         8     0             8 neutral   none  left      left          0\n10   511         9     0             9 neutral   none  left      right         1\n# â„¹ 7,153 more rows\n# â„¹ 2 more variables: rt <dbl>, correct <dbl>\n```\n:::\n:::\n\n\n\n## Daten vorbereiten\n\nDie Variablen `id, condition, cue, direction, choice` sind kategorisch. Wir konvertieren sie zu Faktoren.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf  <- df |>\n  mutate(across(c(id, condition, cue, direction, choice), as_factor))\n```\n:::\n\n\n\n\n## Signal Detection Theory Kennzahlen berechnen\n\nDie Vpn sollten die Richtung des RDKs angeben; diese war entweder 'right' oder 'left' und ist in der Variablen `choice` gespeichert. Wir kÃ¶nnen die Antworten der Vpn mit der tatsÃ¤chlichen Richtung des RDKs vergleichen, um zu bestimmen, ob die Vpn richtig oder falsch geantwortet haben. Wir kÃ¶nnen die Antworten der Vpn und die Richtung des RDKs in vier Kategorien einteilen: Hit, Miss, False Alarm, und Correct Rejection.\n\nWir definieren nun korrekte rechts-Antworten als `Hit`, falsche rechts-Antworten als `Miss`, korrekte links-Antworten als `Correct Rejection`, und falsche links-Antworten als `False Alarm`. \n\n<aside>\nDies ist willkÃ¼rlich - wir kÃ¶nnten genauso gut links und rechts vertauschen.\n</aside>\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- df |>\n    mutate(type = case_when(\n        direction == \"right\" & choice == \"right\" ~ \"Hit\",\n        direction == \"right\" & choice == \"left\" ~ \"Miss\",\n        direction == \"left\" & choice == \"left\" ~ \"CR\",\n        direction == \"left\" & choice == \"right\" ~ \"FA\"\n    ))\n```\n:::\n\n\n\nNun zÃ¤hlen wir die Anzahl `Hit`, `Miss`, `FA`, und `CR` fÃ¼r jede Vp und Bedingung. Wir kÃ¶nnen dies mit `count()` machen.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_cue <- df |>\n      group_by(id, cue) |>\n      count(type)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_cue\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 525 Ã— 4\n# Groups:   id, cue [135]\n   id    cue   type      n\n   <fct> <fct> <chr> <int>\n 1 184   none  CR       31\n 2 184   none  FA        9\n 3 184   none  Hit      19\n 4 184   none  Miss     21\n 5 184   right CR        5\n 6 184   right FA        3\n 7 184   right Hit      15\n 8 184   right Miss     17\n 9 184   left  CR       19\n10 184   left  FA       13\n# â„¹ 515 more rows\n```\n:::\n:::\n\n\nAnschliessend kÃ¶nnen wir die Daten mit `pivot_wider()` in ein `wide` Format umwandeln, so dass jede Kennzahl eine eigene Spalte erhÃ¤lt. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_cue  <- df_cue |>\n    pivot_wider(names_from = type, values_from = n) \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_cue\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 135 Ã— 6\n# Groups:   id, cue [135]\n   id    cue      CR    FA   Hit  Miss\n   <fct> <fct> <int> <int> <int> <int>\n 1 184   none     31     9    19    21\n 2 184   right     5     3    15    17\n 3 184   left     19    13     3     5\n 4 185   none     19    21    20    20\n 5 185   right     5     3    21    11\n 6 185   left     15    17     3     5\n 7 238   none     28    12    12    28\n 8 238   right     3     5    15    17\n 9 238   left     26     6    NA     8\n10 239   none     34     6    23    17\n# â„¹ 125 more rows\n```\n:::\n:::\n\n\n\nEs gibt noch `NA` Werte - deis bedeutet, dass die Vp keine Antworten des entsprechenden Typs gegeben hat. Diese `NA`s mÃ¼ssen wir durch 0 ersetzen, damit wir die Kennzahlen berechnen kÃ¶nnen.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreplace_NA <- function(x) {\n    x = ifelse(is.na(x), 0, x)\n    x\n} \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_cue <- df_cue |>\n  mutate(across(c(Hit, Miss, FA, CR), replace_NA))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_cue\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 135 Ã— 6\n# Groups:   id, cue [135]\n   id    cue      CR    FA   Hit  Miss\n   <fct> <fct> <dbl> <dbl> <dbl> <dbl>\n 1 184   none     31     9    19    21\n 2 184   right     5     3    15    17\n 3 184   left     19    13     3     5\n 4 185   none     19    21    20    20\n 5 185   right     5     3    21    11\n 6 185   left     15    17     3     5\n 7 238   none     28    12    12    28\n 8 238   right     3     5    15    17\n 9 238   left     26     6     0     8\n10 239   none     34     6    23    17\n# â„¹ 125 more rows\n```\n:::\n:::\n\n\n\nNun berechnen wir die relativen HÃ¤ufigkeiten, mit denen `Hit` und `FA` auftreten.  \n\n:::{.callout-tip}\nDie Hit Rate ist die Anzahl `Hits` geteilt durch die Anzahl `Hits` und `Misses` (wie oft hat die Versuchsperson korrekterweise 'rechts' gesagt, wenn der Stimulus tatsÃ¤chlich 'rechts' war?) Die False Alarm Rate ist die Anzahl `FAs` geteilt durch die Anzahl `FAs` und `CRs` (wie oft hat die Versuchsperson fÃ¤lschlicherweise 'rechts' gesagt, wenn der Stimulus tatsÃ¤chlich 'links' war?).\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_cue  <- df_cue |>\n    mutate(hit_rate = Hit/(Hit + Miss),\n           fa_rate = FA/(FA + CR))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_cue\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 135 Ã— 8\n# Groups:   id, cue [135]\n   id    cue      CR    FA   Hit  Miss hit_rate fa_rate\n   <fct> <fct> <dbl> <dbl> <dbl> <dbl>    <dbl>   <dbl>\n 1 184   none     31     9    19    21    0.475   0.225\n 2 184   right     5     3    15    17    0.469   0.375\n 3 184   left     19    13     3     5    0.375   0.406\n 4 185   none     19    21    20    20    0.5     0.525\n 5 185   right     5     3    21    11    0.656   0.375\n 6 185   left     15    17     3     5    0.375   0.531\n 7 238   none     28    12    12    28    0.3     0.3  \n 8 238   right     3     5    15    17    0.469   0.625\n 9 238   left     26     6     0     8    0       0.188\n10 239   none     34     6    23    17    0.575   0.15 \n# â„¹ 125 more rows\n```\n:::\n:::\n\n\nNun gibts es noch eine kleines Problem: Falls es irgendwo eine `hit_rate` oder eine `fa_rate` von 0 oder 1 gibt, kÃ¶nnen wir nicht weiterrechnen. Relative HÃ¤ufigkeiten sind SchÃ¤tzungen von Wahrscheinlichkeiten und mÃ¼ssen daher zwischen 0 oder 1 liegen. Wir kÃ¶nnen dieses Problem lÃ¶sen, indem wir die `hit_rate` und `fa_rate` um _einen kleinen Wert_ erhÃ¶hen oder verringern, falls sie 0 oder 1 sind. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncorrect_zero_one <- function(rate, e = 0.001) {\n    if (identical(rate, 0)) {\n        rate = rate + e\n    } else if (identical(rate, 1)) {\n        rate = rate - e\n    }\n    rate\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_cue <- df_cue |>\n    mutate(across(c(hit_rate, fa_rate), correct_zero_one))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_cue\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 135 Ã— 8\n# Groups:   id, cue [135]\n   id    cue      CR    FA   Hit  Miss hit_rate fa_rate\n   <fct> <fct> <dbl> <dbl> <dbl> <dbl>    <dbl>   <dbl>\n 1 184   none     31     9    19    21    0.475   0.225\n 2 184   right     5     3    15    17    0.469   0.375\n 3 184   left     19    13     3     5    0.375   0.406\n 4 185   none     19    21    20    20    0.5     0.525\n 5 185   right     5     3    21    11    0.656   0.375\n 6 185   left     15    17     3     5    0.375   0.531\n 7 238   none     28    12    12    28    0.3     0.3  \n 8 238   right     3     5    15    17    0.469   0.625\n 9 238   left     26     6     0     8    0.001   0.188\n10 239   none     34     6    23    17    0.575   0.15 \n# â„¹ 125 more rows\n```\n:::\n:::\n\n\nDamit wir nun $d'$ und $c$ berechnen kÃ¶nnen, mÃ¼ssen die `hit_rate` und `fa_rate` in $z$-Werte umgewandelt werden. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_cue <- df_cue |>\n  mutate(zhr = qnorm(hit_rate),\n           zfa = qnorm(fa_rate))\n```\n:::\n\n\n\n\n\nMit den z-transformierten Werten kÃ¶nnen wir nun $d'$ und $c$ berechnen.\n\n$$ c = -\\frac{1}{2} \\left[\\phi^{-1}(p_{H}) + \\phi^{-1}(p_{FA})\\right] =  -\\frac{1}{2} \\left[zH + zFA\\right] $$\n$$ d' = k - \\phi^{-1}(1-p_{H}) = \\phi^{-1}(p_{H}) - \\phi^{-1}(p_{FA}) = zH - zFA $$\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_cue <- df_cue |>\n  mutate(dprime = zhr - zfa,\n         k = -zfa,\n         c = -0.5 * (zhr + zfa)) |>\n    mutate(across(c(dprime, k, c), \\(x) round(x, 2)))\n```\n:::\n\n\n## Grafische Darstellung von Bias und SensitivitÃ¤t\nUm einen Ãœberblick zu gewinnen, stellen wir $c$ und $d'$ grafisch dar. Wir erarten hier, dass die SensitivitÃ¤t unverÃ¤ndert bleibt, da wir diese nicht manipuliert haben. Der Bias sollte sich jedoch zwischen den Bedingungen unterscheiden. In der neutralen Bedingung, d.h. wenn kein Hinweisreiz gegeben wurde, sollte der Bias bei 0 liegen. Falls der Hinweisreiz die Vp dazu bringt, eher 'rechts' zu antworten, sollte der Bias negativ sein. Falls der Hinweisreiz die Vp dazu bringt, eher 'links' zu antworten, sollte der Bias positiv sein.\n\nIn folgendem Veranschaulichung liegt das Kriterium $k$ links der Mitte zwischen beiden Verteilungen. Folglich wird $c = k - d' <0$. Ein negativer Bias fÃ¼hrt dazu, dass die Person eher eine 'rechts'-Antwort gibt. \n\n\n::: {.cell}\n::: {.cell-output-display}\n![](signal-detection-2_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n\n\n\nTatsÃ¤chlich scheint es eine Tendenz zu geben, dass der 'rechts' Hinweis zu einem negativen Bias fÃ¼hrt, wÃ¤hrend der 'links' Hinweis zu einem positiven Bias fÃ¼hrt - die VariabilitÃ¤t zwischen den Versuchspersonen ist jedoch gross, und es scheint einige Personen zu geben, welche genau das Gegenteil zeigen. Es scheint jedoch auch einige Personen zu geben, welche systematisch falsch geantwortet haben (negative SensitivitÃ¤t).\n\n<aside>\nDa die DurchfÃ¼hrung unseres Experiments schlecht kontrolliert wurde (am eigenen Laptop) gehen wir hier nicht nÃ¤her darauf ein. In einem richtigen Experiment wÃ¼rden wir solche Daten nicht zulassen.\n</aside>\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_cue |>\n  ggplot(aes(x = c, y = dprime)) +\n      geom_hline(yintercept = 0, color = \"blue\", linetype = 2) +\n      geom_vline(xintercept = 0, color = \"blue\", linetype = 2) +\n      geom_jitter(size = 1) +\n      facet_wrap(~ cue) +\n      labs(x = \"c\", y = \"d'\") +\n      ggtitle(\"Bias vs. sensitivity\") +\n      theme_linedraw()\n```\n\n::: {.cell-output-display}\n![](signal-detection-2_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n\n\n## Mittelwerte und Standardfehler\n\nNun wollen wir, wie im Kapitel zum Thema 'aggregierte Statistiken', die Bedingungen bezÃ¼glich der SensitivitÃ¤t und des Bias vergleichen. Wir mÃ¼ssen berÃ¼cksichtigen, dass jede Person in 3 Bedingungen getestet wurde - die Art des Hinweisreizes ist also ein `within`-Faktor. \n\nWir wÃ¤hlen zuerst die relevanten Variablen aus.\n\n::: {.cell}\n\n```{.r .cell-code}\nsdt_final <- df_cue |>\n    select(id, cue, dprime, k, c)\n```\n:::\n\n\nNun berechnen wir die Mittelwerte und die `within-person`-Standardfehler der Mittelwerte fÃ¼r den Bias und die SensitivitÃ¤t.\n\n::: {.cell}\n\n```{.r .cell-code}\ncs <- sdt_final |>\n    select(id, cue, c) |>\n    Rmisc::summarySEwithin(measurevar = \"c\",\n                           withinvars = \"cue\",\n                           idvar = \"id\",\n                           na.rm = FALSE,\n                           conf.interval = 0.95)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndprimes <- sdt_final |>\n    select(id, cue, dprime) |>\n    Rmisc::summarySEwithin(measurevar = \"dprime\",\n                           withinvars = \"cue\",\n                           idvar = \"id\",\n                           na.rm = FALSE,\n                           conf.interval = 0.95)\n```\n:::\n\n\n\n## Plots\nAls Beispiel nehmen wir hier den Bias. Wir stellen die Mittelwerte als Linienplot dar, und zusÃ¤tzlich als Punkte mit Fehlerbalken. Die Punkte sind die Mittelwerte, die Fehlerbalken die Standardfehler der Mittelwerte.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncs |>\n    ggplot(aes(x = cue, y = c, group = 1)) + \n    geom_hline(yintercept = 0, \n               linetype = \"dashed\",\n               color = \"grey60\") +\n    geom_line() +\n    geom_errorbar(width = 0.1, aes(ymin = c - ci,\n                                   ymax = c + ci)) +\n    geom_point(shape = 21, size = 3, fill = \"white\") +\n    ggtitle(\"c (bias)\")\n```\n\n::: {.cell-output-display}\n![](signal-detection-2_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\nZusatzlich kÃ¶nnen wir die Datenpunkte plotten; diese sind jedoch im Dataframe `sdt_final` gespeichert, und nicht im Dataframe `cs`. Daher benutzen wir das Argument `data = sdt_final` in `geom_jitter`. \n\n::: {.cell}\n\n```{.r .cell-code}\ncs |>\n    ggplot(aes(x = cue, y = c, group = 1)) + \n    geom_hline(yintercept = 0, \n               linetype = \"dashed\",\n               color = \"grey60\") +\n    geom_jitter(aes(cue, c), alpha = 0.3, data = sdt_final, width = 0.05) +\n    geom_line() +\n    geom_errorbar(width = 0.1, aes(ymin = c - ci,\n                                   ymax = c + ci)) +\n    geom_point(shape = 21, size = 3, fill = \"white\") +\n    ggtitle(\"c (bias)\")\n```\n\n::: {.cell-output-display}\n![](signal-detection-2_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\n\n\n\nMit dem `patchwork` Package kÃ¶nnen wir die beiden Plots kombinieren.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(patchwork)\n    \np_dprime <- dprimes |>\n      ggplot(aes(x = cue, y = dprime, group = 1)) +\n      geom_jitter(aes(cue, dprime), alpha = 0.1, data = sdt_final, width = 0.05) +\n      geom_line() +\n      geom_errorbar(width = 0.1, aes(ymin = dprime - ci,\n                                       ymax = dprime + ci)) +\n      geom_point(shape = 21, size = 3, fill = \"white\") +\n          ggtitle(\"Sensitivity\")\n      \np_bias <- cs |>\n        ggplot(aes(x = cue, y = c, group = 1)) + \n        geom_jitter(aes(cue, c), alpha = 0.1, data = sdt_final, width = 0.05) +\n        geom_hline(yintercept = 0, \n                   linetype = \"dashed\",\n                   color = \"grey60\") +\n          geom_line() +\n          geom_errorbar(width = 0.1, aes(ymin = c - ci,\n                                       ymax = c + ci)) +\n        geom_point(shape = 21, size = 3, fill = \"white\") +\n        ggtitle(\"Bias\")\n  \np_dprime / p_bias\n```\n\n::: {.cell-output-display}\n![](signal-detection-2_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\n\nFalls Ihnen diese Darstellung nicht gefÃ¤llt, kÃ¶nnen Sie die Grafiken mit `+` auch nebeneinander anordnen.\n\n:::{.callout-tip}\nMit `/` werden die Grafiken untereinander angeordnet, mit `+` nebeneinander.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_dprime + p_bias\n```\n\n::: {.cell-output-display}\n![](signal-detection-2_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n\n## Zusammenfassung\n\nDie Bedingungen unterscheiden sich bezÃ¼glich der SensitivitÃ¤t kaum. BezÃ¼glich des Bias sehen wir das erwartete Muster; in der neutralen Bedingung ist der Bias Ã¼ber die Personen aggregiert nahe bei 0, in der 'rechts'-Bedingung negativ und in der 'links'-Bedingung positiv. Ob dies einer statistischen Untersuchung standhÃ¤lt kÃ¶nnten z.B. wir mit einer 'repeated-measures' ANOVA untersuchen.\n",
    "supporting": [
      "signal-detection-2_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}