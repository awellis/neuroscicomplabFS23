{
  "hash": "7758b2a3919cf13aabfa4ee72c693283",
  "result": {
    "markdown": "---\ntitle: \"Funktionen und Schleifen\"\ndescription: Mehrere Datensätze importieren und bearbeiten mit Funktionen und Schleifen.\ndate: \"2023-03-13\"\nauthor:\n  - name: Andrew Ellis\n    url: https://github.com/awellis\n    affiliation: Kognitive Psychologie, Wahrnehmung und Methodenlehre, Universität Bern \n    affiliation-url: https://www.kog.psy.unibe.ch\n    orcid: 0000-0002-2788-936X\nlicense: CC BY\ncitation: true\nbibliography: ../../bibliography.bib\nformat:\n    html:\n        toc: true\n        code-link: true\n---\n\n\n\n\n:::{.callout-tip collapse=\"false\"}\n## Lernziele\n\nIn der heutigen Sitzung lernen wir:\n\n- Mehrere Datensätze importieren\n- Eine Schleife (loop) zu schreiben\n- Eine eigene Funktion schreiben\n- \n:::\n\n\n:::{.callout-caution collapse=\"true\"}\n## Datacamp\n- Falls Sie mir R und den `tidyverse` Packages (noch) nicht sattelfest sind, empfehlen wir Ihnen das erste Kapitel im folgenden Kurs auf DataCamp: [Introduction to the Tidyverse](https://app.datacamp.com/learn/courses/introduction-to-the-tidyverse).\n- In folgendem Datacamp Kurs können Sie Ihr Wissen über Funktionen und Schleifen erweitern und festigen: [Intermediate R](https://app.datacamp.com/learn/courses/intermediate-r)\n\n:::\n\n\n# Mehrere Datensätze einlesen \n\nMeist werden Daten für jede Versuchsperson einzeln abgespeichert. Um nicht jeden Datensatz einzeln einlesen zu müssen können wir Schleifen (loops) und Funktionen nutzen. Schleifen und Funktionen sind immer extrem zeitsparend, wenn ein Prozess wiederholt werden muss. Dies kommt in der Verarbeitung grosser Datensätze häufig vor. Zudem werden so Tippfehler vermieden, die häufig passieren, wenn man dreissig Mal dasselbe schreiben muss.\n\n\n## Schleifen (loops)\n\nSchleifen ermöglichen das x-beliebige Wiederholen eines Schrittes z.B. statt dem einzelnen Einlesen eines Datensatzes, werden alle Datensätze in einem Ordner eingelesen auf einmal eingelesen. \n\nUm mehrere Datensätze einzulesen benötigen wir:\n\n1. Eine Liste aller Datensätze, die man einlesen möchte\n\n2. Eine Schleife, die besagt, dass wir für jedes Objekt in der Liste etwas machen möchten\n\n3. Eine Aufgabe, die wir mit jedem Objekt ausführen möchten\n\nMit einer Schleife sagt man dem Programm \"Führe für jeden Datensatz dieser Liste folgendes durch: Lade den Datensatz.\"\n\n\nEine Schleife wird in R wie folgt formuliert:\n\n\n\n\n\n::: {.cell hash='functions_and_loops-2_cache/html/unnamed-chunk-3_ad1f93264eaeafc9d96be50ed99dd1a5'}\n\n```{.r .cell-code}\nfor (var in seq){\n    expr\n}\n```\n:::\n\n\nMit `var` ist eine Variable in einer Sequenz `seq` gemeint. Bei uns wäre die Variable ein Name eines Datensatzes, und die Sequenz wäre eine Liste mit Datensätzen (z.B. alle Files in einem Ordner). `expr` meint _expression_, also was wir mit dieser Variable tun wollen, in unserem Beispiel wollen wir den Datensatz öffnen.\n\n\n|              | Inhalt         | Bsp. Datensatz einlesen |\n|------------- |--------------- |------------------------|\n| `var`        | Laufvariable   | Name des einzelnen Datensatzes|\n| `seq`        | Sequenz/Vektor | Liste mit Namen aller Datensätze |\n| `expr`       | Schritt/Aufgabe| Öffnen des Datensatzes |\n\nNun müssen wir statt `var`, `seq` und `expr` natürlich sinnvolle Variablen und Schritte einfügen.\nZuerst erstellen wir die Liste, über die die Schleife laufen soll. \n\n\n::: {.cell hash='functions_and_loops-2_cache/html/unnamed-chunk-4_c443bc3ced5b16f1b84b0bc7a734c24b'}\n\n```{.r .cell-code}\nmyFiles <- list.files(path = \"../../data/rdk_decision_experiment/data\",  # Pfad des Ordners mit den Datensätzen\n                      pattern = \".csv\", # Endung der Datensätze, hier .csv\n                      full.names = TRUE) \n\nmyFiles # zeige die Liste\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"../../data/rdk_decision_experiment/data/JH_rdk-discrimination_2022_Mar_07_1403.csv\"   \n[2] \"../../data/rdk_decision_experiment/data/NS_rdk-discrimination_2022_Mar_07_1331.csv\"   \n[3] \"../../data/rdk_decision_experiment/data/rh_rdk-discrimination_2022_Mar_02_1105.csv\"   \n[4] \"../../data/rdk_decision_experiment/data/sb_rdk-discrimination_2022_Mar_06_0746.csv\"   \n[5] \"../../data/rdk_decision_experiment/data/SS91_rdk-discrimination_2022_Mar_06_0953.csv\" \n[6] \"../../data/rdk_decision_experiment/data/VP1_rdk-discrimination_2022_Mar_07_1237.csv\"  \n[7] \"../../data/rdk_decision_experiment/data/VP2_rdk-discrimination_2022_Mar_07_1302.csv\"  \n[8] \"../../data/rdk_decision_experiment/data/VPN01_rdk-discrimination_2022_Mar_01_2142.csv\"\n[9] \"../../data/rdk_decision_experiment/data/VPN02_rdk-discrimination_2022_Mar_01_2208.csv\"\n```\n:::\n:::\n\n\nDie Variable `var` können wir beliebig benennen, wir wählen hier `file`. Danach können wir die Schleife erstellen, die für jedes `file` in `myFiles` den Schritt _Daten laden_ mit `read.csv` ausführt. Das sieht dann so aus:\n\n<aside> Diese Variable wird oft `i` oder `j` genannt. </aside>\n\n\n::: {.cell hash='functions_and_loops-2_cache/html/unnamed-chunk-5_0084049ffbe6d8c4622aa5491d3fe55f'}\n\n```{.r .cell-code}\nd <- NULL # Vorbereiten des Datensatzes \n\nfor (file in myFiles){\n    dataset <- read.csv(file)\n    d <- rbind(d, dataset) # wir fügen jeden neu eingelesenen Datensatz hinzu\n} \n```\n:::\n\n\n\n## Funktionen\n\nStatt der Schleife, können wir es uns aber noch einfacher machen, in dem wir statt einer Schleide die Funktion `map`verwenden. \nFunktionen sind sehr hilfreich, wenn man einen Schritt mehrmals machen will. Funktionen sind kleine Programme, denen man Infos geben muss (Parameter) und die dann immer dasselbe mit diesen Infos machen. Eine Funktion hat folgende Struktur:\n\n\n::: {.cell hash='functions_and_loops-2_cache/html/unnamed-chunk-6_9d13efe944929cef6bee9520f22c5920'}\n\n```{.r .cell-code}\nfunctionname <- function(parameter) {\n  body\n}\n```\n:::\n\n\n\nDie Funktion `mean()`zum Beispiel macht immer dasselbe mit den Zahlen, die man ihr füttert.\n\n\n::: {.cell hash='functions_and_loops-2_cache/html/unnamed-chunk-7_7cb5780992aa27b42e87adf47cfda97f'}\n\n```{.r .cell-code}\nx <- c(1, 21, 3, 234, 5) # verschiedene Zahlen\n\nmean(x)\n```\n:::\n\n:::{.callout-important}\nWas macht die Funktion `mean()`?\n\nTipp: Geben Sie `?mean` in Ihre R-Konsole ein. \n\n- Was kann man bei der Funktion `mean()` als Parameter eingeben?\n\n- Muss die eingegebene Variable `x` heissen? Probieren Sie aus.\n\n- Was passiert, wenn man `mean(x, trim = 1)` eingibt? \n\n- Was bedeutet `na.rm`? Fügen Sie im Vektor `x` ein `NA`hinzu und probieren Sie es aus.\n:::\n\n\nUm unsere Daten einzulesen verwenden wir die Funktion `map` vom Package `purrr`. Diese Funktion ist sehr praktisch. Sie nimmt als Parameter unsere Liste mit den Datensätzen und wendet für jeden Punkt in der Liste das an, was wir in Klammern angeben. Wir wollen Daten einlesen also schreiben wir hier: `read.csv`. Anschliessend müssen wir die Listen noch zu einem Datensatz umwandeln indem wir alle untereinander anordnen, also die `List`en `r`eihenweise `bind`en: `list_rbind()`. \n\n<aside> Falls Sie das Package `purrr` noch nicht installiert haben, können Sie in der Konsole `install.packages(\"purrr\")` eingeben. Jedes Package muss nur einmal installiert werden. Will man es verwenden, muss es aber mit `library(purrr)` geladen werden. Statt `list_rbind`zu verwenden könnten wir auch `map_dfr`nutzen, dann wäre der Code noch kompakter. </aside>\n\n\n::: {.cell hash='functions_and_loops-2_cache/html/unnamed-chunk-8_901ab7777c0bebeb95c29758cd11d399'}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.0     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.1     ✔ tibble    3.1.8\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n\n```{.r .cell-code}\nlibrary(purrr)\n\nd <- myFiles %>%\n    map(read.csv) |>\n    list_rbind()\n\nglimpse(d, width = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1,503\nColumns: 40\n$ cue                                        <chr> …\n$ direction                                  <chr> …\n$ practice_block_loop.thisRepN               <int> …\n$ practice_block_loop.thisTrialN             <int> …\n$ practice_block_loop.thisN                  <int> …\n$ practice_block_loop.thisIndex              <int> …\n$ main_blocks_loop.thisRepN                  <int> …\n$ main_blocks_loop.thisTrialN                <int> …\n$ main_blocks_loop.thisN                     <int> …\n$ main_blocks_loop.thisIndex                 <int> …\n$ static_isi.started                         <dbl> …\n$ static_isi.stopped                         <dbl> …\n$ fixation_pre.started                       <dbl> …\n$ fixation_pre.stopped                       <chr> …\n$ image.started                              <dbl> …\n$ image.stopped                              <chr> …\n$ fixation_post.started                      <dbl> …\n$ fixation_post.stopped                      <chr> …\n$ dots_background.started                    <dbl> …\n$ dots_background.stopped                    <chr> …\n$ dots_stimulus.started                      <dbl> …\n$ dots_stimulus.stopped                      <chr> …\n$ dots_keyboard_response.keys                <chr> …\n$ dots_keyboard_response.started             <dbl> …\n$ dots_keyboard_response.stopped             <chr> …\n$ feedback_text.started                      <dbl> …\n$ feedback_text.stopped                      <chr> …\n$ dots_keyboard_response.rt                  <dbl> …\n$ instruction_main_text.started              <dbl> …\n$ instruction_main_text.stopped              <chr> …\n$ instruction_main_keyboard_response.keys    <chr> …\n$ instruction_main_keyboard_response.rt      <dbl> …\n$ instruction_main_keyboard_response.started <dbl> …\n$ instruction_main_keyboard_response.stopped <chr> …\n$ Pseudonym                                  <chr> …\n$ date                                       <chr> …\n$ expName                                    <chr> …\n$ psychopyVersion                            <chr> …\n$ frameRate                                  <dbl> …\n$ X                                          <lgl> …\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}