{
  "hash": "3ebb614f8c417bde295a7b7901b5b6bb",
  "result": {
    "markdown": "---\ntitle: \"√úbung 4\"\ndescription: |\n   Untersuchung eines pr√§symptomatischen Indikators f√ºr die Alzheimer-Krankheit\ndate: \"2022-05-05\"\nauthor:\n  - name: Andrew Ellis\n    url: https://github.com/awellis\n    affiliation: Kognitive Psychologie, Wahrnehmung und Methodenlehre, Universit√§t Bern \n    affiliation-url: https://www.kog.psy.unibe.ch\n    orcid: 0000-0002-2788-936X\n  - name: Gerda Wyssen\n    affiliation: Kognitive Psychologie, Wahrnehmung und Methodenlehre, Universit√§t Bern \n    affiliation-url: https://www.kog.psy.unibe.ch\n    orcid: 0000-0001-7427-3149\nlicense: CC BY\ncitation: true\nbibliography: ../../bibliography.bib\nformat:\n    html:\n        toc: true\n        code-link: true\nexecute: \n  cache: false\ncode-annotations: select\n---\n\n\n\n\n\n\n:::{.callout-tip}\n## RStudio Projekt\n\nüëâ [RStudio Projekt f√ºr diese √úbung herunterladen](../../downloadable_files/amyloidSDT.zip)\n\nSie finden darin ein Rmarkdown-File, welches Sie bearbeiten m√ºssen, und den Datensatz. \n:::\n\n\n:::{.callout-tip collapse=\"false\"}\n## Aufgaben\nDie √úbung 4 besteht aus den zwei folgenden Aufgaben:\n\n**1. Rmarkdown-File ausf√ºhren**: In diesem File werden die Daten eingelesen, SDT Kennzahlen berechnet und Grafiken erstellt. Beantworten Sie die Fragen direkt im Rmarkdown-File. Das Rmarkdown-File muss von einer anderen Person ausgef√ºhrt werden k√∂nnen (Reproduzierbarkeit). Zeit: 1 Woche.\n\n**2. Peer Feedback**: Mittels Ilias wird Ihnen das Rmarkdown-File einer anderen Person zugeordnet. Ihr Auftrag ist es, dieses Rmarkdown-File auszuf√ºhren und Feedback zu geben. Zeit: 1 Woche.\n:::\n\n\n\n## Einleitung\nIn √úbung 4 arbeiten wir mit einem klinischen Datensatz. Das Ziel ist es, Sensitivit√§t und Bias f√ºr zwei Gruppen von insgesamt 60 Patienten zu untersuchen, die sich in ihrem Risiko f√ºr Alzheimer-Krankheit unterscheiden. \n\nDie Anwesenheit von [Beta-Amyloid](https://de.wikipedia.org/wiki/Beta-Amyloid) wurde durch einen [Bluttest](https://www.nia.nih.gov/news/blood-test-can-predict-presence-beta-amyloid-brain-new-study-finds) untersucht. Ein positiver Beta-Amyloid Test gilt als pr√§symptomatischer Indikator f√ºr die Alzheimer-Krankheit.\n\nAufgrund dieses Bluttests wurden die Patienten in zwei Gruppen eingeteilt. Es soll nun untersucht werden, ob sich die beiden in ihrer Ged√§chtnisleistung unterscheiden. \n\nDazu wurde der \"Rey auditory verbal learning test\" [@beanReyAuditoryVerbal2011] durchgef√ºhrt. \n\nIn diesem Test m√ºssen Patienten zuerst eine Liste bestehend aus 15 W√∂rtern lernen. Sie werden danach mit 30 W√∂rtern getestet (15 alte, 15 neue W√∂rter) und m√ºssen angeben, ob ein Wort auf der Liste war oder nicht (alt/neu). \n\nDie Antworten der Patienten wurden bereits als als korrekte oder inkorrekte 'Ja'-Antworten klassifiziert (`hits`  und `false alarms`). \n\n## Packages laden\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(patchwork)\n```\n:::\n\n\n\n## Daten laden\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- read_csv(\"data/amyloidSDT.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 60 Columns: 6\n‚îÄ‚îÄ Column specification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nDelimiter: \",\"\nchr (1): group\ndbl (5): ID, hit, miss, fa, cr\n\n‚Ñπ Use `spec()` to retrieve the full column specification for this data.\n‚Ñπ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n:::\n\n\nWir empfehlen, immer zuerst die Daten anzuschauen.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 60 √ó 6\n      ID group      hit  miss    fa    cr\n   <dbl> <chr>    <dbl> <dbl> <dbl> <dbl>\n 1     1 Negative    13     2     0    15\n 2     2 Negative    12     3     1    14\n 3     3 Negative    14     1     0    15\n 4     4 Negative    12     3     1    14\n 5     5 Negative    11     4     2    13\n 6     6 Negative    12     3     1    14\n 7     7 Negative    10     5     2    13\n 8     8 Negative    13     2     1    14\n 9     9 Negative    12     3     0    15\n10    10 Negative    12     3     2    13\n# ‚Ñπ 50 more rows\n```\n:::\n:::\n\n\nIm Datensatz halben wir folgende Variablen: \n\n\n- `ID`: Patienten-ID\n- `group`: Indikator f√ºr Beta-Amyloid Bluttest (Negative oder Positive)\n- `hit`: Anzahl hits\n- `miss`: Anzahl misses\n- `fa`: Anzahl false alarms\n- `cr`: Anzahl correct rejections\n\n\nIm Datensatz gibt es es einige Nullen -- z.B. hat die Person mit der `ID` 1 keine False Alarms. Dies ist problematisch, weil wir die relative H√§ufigkeiten von Hits (`hit_rate`) und False Alarms (`fa_rate`) berechnen und diese anschliessend z-transformieren wollen. Die `fa_rate` ist der Anteil 'Ja'-Antworten wenn das Wort tats√§chlich gar nicht auf der Liste war, also `fa / (fa + cr)`. Bei der ersten Person w√§re dies `0/(0 + 15) = 0`. \n\nDas Problem ist nun, dass wir hier mit der relativen H√§ufigkeit eine Wahrscheinlichkeit sch√§tzen - eine Wahrscheinlichkeit darf aber nicht $0$ sein, sondern liegt zwischen $-\\infty$ und $\\infty$. Wenn wir `qnorm()` (die Quantilfunktion der Normalverteilung) auf den Wert $0$ anwenden, erhalten wir:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqnorm(0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -Inf\n```\n:::\n:::\n\n\nDamit k√∂nnen wir nicht weiterrechnen. Wir wenden daher einen Trick an: wir addieren einfach zu jeder Zelle im Datensatz den Wert $0.5$. Somit erhalten wir f√ºr die `fa_rate` der ersten Person:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n0 + 0.5 / (0 + 0.5 + 15 + 0.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.03125\n```\n:::\n:::\n\n\n\nDies bedeutet, dass wir einen kleine Wahrscheinlichkeit erhalten; diese ist aber nicht Null. Diesen Wert k√∂nnen wir nun in `qnorm()` einsetzen.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqnorm(0.03125)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -1.862732\n```\n:::\n:::\n\n\n## Den Wert `0` ersetzen\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_half_count <- function(count) {\n    count + 0.5\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- d |>\n    mutate(across(c(hit, miss, fa, cr), add_half_count))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 60 √ó 6\n      ID group      hit  miss    fa    cr\n   <dbl> <chr>    <dbl> <dbl> <dbl> <dbl>\n 1     1 Negative  13.5   2.5   0.5  15.5\n 2     2 Negative  12.5   3.5   1.5  14.5\n 3     3 Negative  14.5   1.5   0.5  15.5\n 4     4 Negative  12.5   3.5   1.5  14.5\n 5     5 Negative  11.5   4.5   2.5  13.5\n 6     6 Negative  12.5   3.5   1.5  14.5\n 7     7 Negative  10.5   5.5   2.5  13.5\n 8     8 Negative  13.5   2.5   1.5  14.5\n 9     9 Negative  12.5   3.5   0.5  15.5\n10    10 Negative  12.5   3.5   2.5  13.5\n# ‚Ñπ 50 more rows\n```\n:::\n:::\n\n\n## Hit und False Alarm Rate berechnen\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- d |>\n    mutate(\n        hit_rate = hit / (hit + miss),\n        fa_rate = fa / (fa + cr)\n    )\n```\n:::\n\n\n\n## Hit Rate vs False Alarm Rate\n\nBevor wir die SDT Kennzahlen berechnen, stellen wir die hit rate und false alarm rate grafisch dar:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd |>\n      ggplot(aes(fa_rate, hit_rate, color = group)) +\n      geom_abline(intercept = 0, slope = 1, linetype = 2) +\n      geom_jitter() +\n      scale_color_viridis_d(direction = -1, begin = 0.1, end = 0.8) +\n      facet_wrap(~ group) +\n      xlim(c(0, 1)) +\n      theme_linedraw()\n```\n\n::: {.cell-output-display}\n![](uebung-4-signal-detection_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n## d' und bias berechnen\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- d |>\n    mutate(\n        zhr = qnorm(hit_rate),\n        zfa = qnorm(fa_rate)\n    )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- d |>\n    mutate(\n        dprime = zhr - zfa,\n        k = -zfa,\n        c = -0.5 * (zhr + zfa)\n    )\n```\n:::\n\n\nWir runden nun `dprime, k` und `c` auf zwei Nachkommastellen.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- d |>\n    mutate(across(c(dprime, k, c), \\(x) round(x, 2)))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 60 √ó 13\n      ID group   hit  miss    fa    cr hit_rate fa_rate   zhr   zfa dprime     k\n   <dbl> <chr> <dbl> <dbl> <dbl> <dbl>    <dbl>   <dbl> <dbl> <dbl>  <dbl> <dbl>\n 1     1 Nega‚Ä¶  13.5   2.5   0.5  15.5    0.844  0.0312 1.01  -1.86   2.87  1.86\n 2     2 Nega‚Ä¶  12.5   3.5   1.5  14.5    0.781  0.0938 0.776 -1.32   2.09  1.32\n 3     3 Nega‚Ä¶  14.5   1.5   0.5  15.5    0.906  0.0312 1.32  -1.86   3.18  1.86\n 4     4 Nega‚Ä¶  12.5   3.5   1.5  14.5    0.781  0.0938 0.776 -1.32   2.09  1.32\n 5     5 Nega‚Ä¶  11.5   4.5   2.5  13.5    0.719  0.156  0.579 -1.01   1.59  1.01\n 6     6 Nega‚Ä¶  12.5   3.5   1.5  14.5    0.781  0.0938 0.776 -1.32   2.09  1.32\n 7     7 Nega‚Ä¶  10.5   5.5   2.5  13.5    0.656  0.156  0.402 -1.01   1.41  1.01\n 8     8 Nega‚Ä¶  13.5   2.5   1.5  14.5    0.844  0.0938 1.01  -1.32   2.33  1.32\n 9     9 Nega‚Ä¶  12.5   3.5   0.5  15.5    0.781  0.0312 0.776 -1.86   2.64  1.86\n10    10 Nega‚Ä¶  12.5   3.5   2.5  13.5    0.781  0.156  0.776 -1.01   1.79  1.01\n# ‚Ñπ 50 more rows\n# ‚Ñπ 1 more variable: c <dbl>\n```\n:::\n:::\n\n\n\n\n\n## Aggregierte Kennzahlen\n\n::: {.cell}\n\n```{.r .cell-code}\nse <- function(x) {\n  sd(x) / sqrt(length(x))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndprimes <- d |>\n  select(group, dprime) |> \n  group_by(group) |> \n  summarize(mean = mean(dprime),\n            se = se(dprime))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncs <- d |> \n  select(group, c) |> \n  group_by(group) |> \n  summarize(mean = mean(c),\n            se = se(c))\n```\n:::\n\n\n\n## Grafische Darstellung von `d'` und `bias`\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_dprimes <- dprimes |>\n  ggplot(aes(x=group, y=mean, group=1)) +\n    geom_jitter(aes(group, dprime), alpha = 0.1, data = d, width = 0.05) +\n    geom_line() +\n    geom_errorbar(width=.1, aes(ymin=mean-se, ymax=mean+se), colour=\"black\") +\n    geom_point(shape=21, size=3, fill=\"white\") +\n    ylab(\"Sensitivity\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\np_cs <- cs |>\n    ggplot(aes(x=group, y=mean, group=1)) +\n    geom_jitter(aes(group, c), alpha = 0.1, data = d, width = 0.05) +\n    geom_line() +\n    geom_errorbar(width=.1, aes(ymin=mean-se, ymax=mean+se), colour=\"black\") +\n    geom_point(shape=21, size=3, fill=\"white\") +\n    ylab(\"Bias\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\np_dprimes + p_cs\n```\n\n::: {.cell-output-display}\n![](uebung-4-signal-detection_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n## Fragen\n\nBitte versuchen Sie, folgende Fragen so gut wie m√∂glich zu beantworten. Schreiben Sie Ihre Antworten direkt unter die Fragen.\n\n\n### Frage 1 \n>Wie unterscheiden sich die Gruppen in der `hit rate` und `false alarm rate` (siehe erste Grafik)?\n\n**Antwort**:  \n\n### Frage 2 \n> Wie unterscheidet sich die Sensitivit√§t zwischen den Gruppen im RALVT? Was k√∂nnte das bedeuten? Denken Sie, dass der Unterschied von relevanter Gr√∂sse ist?\n \n**Antwort**: \n\n### Frage 3 \n> Wie unterscheidet sich die Antworttendenz zwischen den Gruppen im RALVT? Was k√∂nnte das bedeuten? Denken Sie, dass der Unterschied von relevanter Gr√∂sse ist? \n \n**Antwort**: \n\n### Frage 4 \n> Wie denken Sie h√§ngen Sensitivit√§t und Antworttendenz in diesem Experiment zusammen? Was k√∂nnten die Gr√ºnde sein? Was passiert, wenn d' kleiner wird, das Kriterium k aber konstant bleibt? Eventuell hilft diese Grafik, um dar√ºber nachzudenken.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](uebung-4-signal-detection_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\n\n\n## Fragen f√ºr Peer Review\n\n√ñffnen Sie das `.Rmd`-File und f√ºhren Sie es mit `Knit` oder von oben bis unten aus und schreiben Sie zu den Antworten eine R√ºckmeldung in ein Word/Text-File.\n\n\n## Hochladen\n\nLaden Sie Ihr Peer Review anschliessend als Word/Text-File auf Ilias hoch.\n",
    "supporting": [
      "uebung-4-signal-detection_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}