{
  "hash": "9b7bf0c977ed31d172ebc4f7dfa3cee9",
  "result": {
    "markdown": "---\ntitle: \"Tasks automatisieren\"\ndescription: Ein Exkurs zu den Themen Conditionals, Funktionen und Loops.\ndate: \"2023-03-13\"\nauthor:\n  - name: Andrew Ellis\n    url: https://github.com/awellis\n    affiliation: Kognitive Psychologie, Wahrnehmung und Methodenlehre, Universität Bern \n    affiliation-url: https://www.kog.psy.unibe.ch\n    orcid: 0000-0002-2788-936X\nlicense: CC BY\ncitation: true\nbibliography: ../../bibliography.bib\nformat:\n    html:\n        toc: true\n        code-link: true\n---\n\n\n:::{.callout-tip collapse=\"false\"}\n## Lernziele\n\nIn der heutigen Sitzung lernen wir:\n\n- Conditionals und Control Flow\n- Funktionen erstellen\n- Loops anwenden\n:::\n\nWir nun zwei Programmierkonzepte kennenlernen, die uns dabei helfen, Tasks zu automatisieren. Wir werden hier nicht in die Tiefe gehen; es geht uns vielmehr darum, Ihnen einen Überblick zu geben, was Sie mit diesen Konzepten machen können. Falls Sie tiefer in die Materie einsteigen möchten, gibt es entsprechende Kurse auf Datacamp.\n\n\n:::{.callout-caution collapse=\"true\"}\n## Datacamp\n- Falls Sie eine Einführung in Programmierkonzepte (Conditionals and Control Flow, Functions, Loops) benötigen, empfehlen wir Ihnen den Datacamp Kurs [Intermediate R](https://app.datacamp.com/learn/courses/intermediate-r).\n:::\n\n\n# Conditionals und Control Flow\n\nConditionals und Control Flow sind Konzepte, die es uns ermöglichen, den Programmablauf zu steuern. Wir können damit zum Beispiel entscheiden, ob ein bestimmter Codeblock ausgeführt wird oder nicht. Wir können auch den Programmablauf abhängig von bestimmten Bedingungen steuern. Dies ist nützlich, wenn wir zum Beispiel eine bestimmte Aktion nur dann ausführen wollen, wenn eine Bedingung erfüllt ist.\n\nAls simples Beispiel wollen wir eine Zahl `x` definieren und prüfen, ob diese grösser als 0 ist. Wenn ja, dann wollen wir die Zahl ausgeben. Wenn nein, dann wollen wir eine Fehlermeldung ausgeben. Um diesen Test `x > 0` auszuführen, können wir `if` verwenden. `if` testet, ob eine Bedingung wahr ist. Falls ja, wird ein Codeblock ausgeführt. Der Codeblock wird in geschweiften Klammern `{}` eingeschlossen. Wenn die Bedingung nicht erfüllt ist, dann wird der Codeblock nicht ausgeführt. Falls die Bedingung nicht wahr ist, können wir eine Alternative mit `else` angeben. Der Codeblock, der ausgeführt wird, wenn die Bedingung nicht wahr ist, wird ebenfalls in geschweiften Klammern `{}` eingeschlossen.\n\n\n::: {.cell hash='functions-loops_cache/html/unnamed-chunk-1_767354ab9c3ff56de80f0be51b9d0bf7'}\n\n```{.r .cell-code}\nx <- 1\n```\n:::\n\n::: {.cell hash='functions-loops_cache/html/unnamed-chunk-2_966fa521e9e1ea7ab75d60a99e7cb5bd'}\n\n```{.r .cell-code}\nif (x > 0) {\n  print(x)\n} else {\n  print(\"x is not greater than 0\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\n\n\n:::{.callout-important}\nÄndern sie den Wert von `x` und führen Sie den Codeblock erneut aus. Was passiert, wenn `x` negativ ist?\n:::\n\n\n\nWir können nun auch mehrere Bedingungen testen. Dazu verwenden wir `if`, `else if` und `else`. `else if` ist eine Alternative zu `else`, wenn die erste Bedingung nicht wahr ist. `else if` wird  dann ausgeführt, wenn die erste Bedingung nicht wahr war. `else` wird nur dann ausgeführt, wenn alle vorherigen Bedingungen nicht wahr waren.\n\nZum Beispiel wollen nun ebenfalls prüfen, ob `x` gleich 0 ist. Falls ja, dann wollen wir eine andere Fehlermeldung ausgeben. Falls nein, dann wollen wir die Fehlermeldung ausgeben, die wir bereits definiert haben.\n\n\n::: {.cell hash='functions-loops_cache/html/unnamed-chunk-3_5c3e268a7410dae0a3e25ca47d258023'}\n\n```{.r .cell-code}\nif (x > 0) {\n  print(x)\n} else if (x == 0) {\n  print(\"x is 0\")\n} else  {\n    print(\"x is not greater than 0\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\n:::{.callout-important}\nÄndern sie den Wert von `x` erneut und führen Sie den Codeblock aus. Was passiert, wenn `x` Null ist?\n:::\n\n# Funktionen\n\nIn R kann man Funktionen selber definieren. Dies ist einerseits nützlich, wenn man etwas berechnen will, es in R aber dafür keine Funktion gibt; andererseits sind Funktion nützlich, um Code zu strukturieren und zu modularisieren. Dies bedeutet, dass man Schritte in einer Funktion zusammenfassen kann, und diese dann testen und wiederverwenden kann. Eine Daumenregel ist: Wenn Sie einen Codeblock mehr als einmal verwenden, dann sollten Sie ihn in eine Funktion packen.\n\n\nEine Funktion besteht aus einem Funktionsnamen, einem oder mehreren Argumenten und einem Funktionskörper. Der Funktionskörper ist der Code, der ausgeführt wird, wenn die Funktion aufgerufen wird. Der Funktionsname ist der Name, unter dem die Funktion in R bekannt ist. Die Argumente sind Werte, welche die Funktion als Input erhält. Funktionen werden mit der Funktion `function()` definiert.\n\n\nWir definieren nun eine Funktion, welche irgendeine eine Zahl `x` \nals Input erhält und die Zahl `x + 1` als Output zurückgibt.\n\n`add_one` ist der Funktionsname. `x` ist das beliebige Argument. Innerhalb der geschweiften Klammern `{}` ist der Funktionskörper, d.h. der Code, welcher ausgeführt wird, wenn die Funktion aufgerufen wird.\n\n\n\n::: {.cell hash='functions-loops_cache/html/unnamed-chunk-4_20b65af503ffcc451d2fb8f82f0a42bd'}\n\n```{.r .cell-code}\nadd_one <- function(x) {\n  x + 1\n}\n```\n:::\n\n\nDieser Code muss in R einmal ausgeführt werden, damit die Funktion `add_one` definiert wird. Danach kann \n`add_one` aufgerufen werden.\n\n\n::: {.cell hash='functions-loops_cache/html/unnamed-chunk-5_c7623324864a968450de17cbf3c5f1e0'}\n\n```{.r .cell-code}\nadd_one(30)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 31\n```\n:::\n:::\n\n\nWas passiert aber nun, wenn wir `add_one` mit einem String aufrufen? Wir erhalten einen Fehler, da wir die Funktion `add_one` nicht mit einem String aufrufen können. Wir können die Funktion `add_one` nur mit Zahlen aufrufen.\n\n\n::: {.cell hash='functions-loops_cache/html/unnamed-chunk-6_1de586173fd39a058f9e1c6ec61d5086'}\n\n```{.r .cell-code}\nadd_one(\"Hello\")\n```\n:::\n\n\nEs wäre sinnvoll, den Input zu prüfen, bevor die Funktion ausgeführt wird. Dies bedeutet, dass wir mit der Funktion `is.numeric()` prüfen, ob der Input eine Zahl ist. Falls der Input keine Zahl ist, dann wollen wir eine Fehlermeldung ausgeben. Falls der Input eine Zahl ist, dann wollen wir die Funktion `add_one` ausführen. Wir können dies mit `if` und `else` tun.\n\n\n::: {.cell hash='functions-loops_cache/html/unnamed-chunk-7_d444e643b78a73ec5bc0b0780edc9f6a'}\n\n```{.r .cell-code}\nadd_one <- function(x) {\n  if (is.numeric(x)) {\n    x + 1\n  } else {\n    print(\"x is not numeric\")\n  }\n}\n```\n:::\n\n::: {.cell hash='functions-loops_cache/html/unnamed-chunk-8_705dd3129821026696a86b90add5b441'}\n\n```{.r .cell-code}\nadd_one(\"Hello\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"x is not numeric\"\n```\n:::\n:::\n\n\n\n\n\n# Loops    \n\nMit Loops können wir über Vektoren oder Listen iterieren. Dies bedeutet, dass wir einen oder mehrere Schritte in einem Codeblock für jedes Element eines Vektors oder einer Liste ausführen können. Wir können Loops mit `for` definieren. \n\nDer Codeblock wird in geschweiften Klammern `{}` eingeschlossen. Der Codeblock wird für jedes Element des Vektors oder der Liste ausgeführt. In einer `for`-Schleife brauchen wir eine spezielle Variable, welche bei jedem Durchlauf des Loops den Wert des aktuellen Elements erhält. Diese Variable nennt man eine Iterationsvariable; diese wird oft `i` genannt (dies ist aber keine Vorschrift, wir können genausogut auch andere Namen verwenden).\n\n\n\nAls erstes Beispiel wollen wir die Namen einzelner Früchte aus einem Vektor ausgeben. \n\n\n::: {.cell hash='functions-loops_cache/html/unnamed-chunk-9_a0430e9fdd0eea1d167b5f53860edaca'}\n\n```{.r .cell-code}\nfruits <- c(\"apple\", \"banana\", \"orange\", \"cherry\")\n```\n:::\n\n::: {.cell hash='functions-loops_cache/html/unnamed-chunk-10_a545524bccdb8e37b44b2d72628bb24c'}\n\n```{.r .cell-code}\nfor (fruit in fruits) {\n    print(fruit)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"apple\"\n[1] \"banana\"\n[1] \"orange\"\n[1] \"cherry\"\n```\n:::\n:::\n\n\nWir können auch eine deskriptive Nachricht ausgeben. \n\n\n\n::: {.cell hash='functions-loops_cache/html/unnamed-chunk-11_47b58c90013fac64730eb7ce2f10a478'}\n\n```{.r .cell-code}\nfor (fruit in fruits) {\n  print(paste(fruit, \"is a fruit\"))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"apple is a fruit\"\n[1] \"banana is a fruit\"\n[1] \"orange is a fruit\"\n[1] \"cherry is a fruit\"\n```\n:::\n:::\n\n\n\nNun können wir einige der Konzepte kombinieren. Wir wollen nun jedes Element einer Liste testen, ob es eine Frucht oder ein Gemüse ist. Falls es eine Frucht ist, wollen wir die Message \"is a fruit\" ausgeben. Falls es ein Gemüse ist, wollen wir die Message \"is a vegetable\" ausgeben. \n\n\n::: {.cell hash='functions-loops_cache/html/unnamed-chunk-12_5186bc96ce49c5242eed01f112148926'}\n\n```{.r .cell-code}\nfruits <- c(\"apple\", \"banana\", \"orange\", \"cherry\")\nvegetables <- c(\"carrot\", \"potato\", \"tomato\", \"cucumber\")\n```\n:::\n\n\n\n\nWir erstellen nun eine zufällige Liste von Früchten und Gemüse. \n\n\n::: {.cell hash='functions-loops_cache/html/unnamed-chunk-13_39bf5fe1a482193394ac1ab0d183d2d0'}\n\n:::\n::: {.cell hash='functions-loops_cache/html/unnamed-chunk-14_927f041690cf3ed592fb4c8cefb43d0a'}\n\n```{.r .cell-code}\nset.seed(589)\nfoods <- sample(c(sample(fruits, 3), sample(vegetables, 3)))\nfoods\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"cucumber\" \"carrot\"   \"orange\"   \"cherry\"   \"banana\"   \"tomato\"  \n```\n:::\n:::\n\n\nWie können wir nun feststellen, ob ein Element in der Liste eine Frucht oder ein Gemüse ist? Wir können dies z.B. mit `%in%` tun. `%in%` prüft, ob ein Element in einem Vektor enthalten ist. \n\n\n::: {.cell hash='functions-loops_cache/html/unnamed-chunk-15_2937c8cb1d881f4f50546ec093bf28de'}\n\n```{.r .cell-code}\n\"apple\" %in% fruits\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n::: {.cell hash='functions-loops_cache/html/unnamed-chunk-16_f14769fc029736a15d45e997cf5bd258'}\n\n```{.r .cell-code}\nfor (food in foods) {\n    if (food %in% fruits) {\n        print(paste(food, \"is a fruit\"))\n    } else if (food %in% vegetables) {\n        print(paste(food, \"is a vegetable\"))\n    } else {\n        print(paste(food, \"is neither fruit nor vegetable\"))\n    }\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"cucumber is a vegetable\"\n[1] \"carrot is a vegetable\"\n[1] \"orange is a fruit\"\n[1] \"cherry is a fruit\"\n[1] \"banana is a fruit\"\n[1] \"tomato is a vegetable\"\n```\n:::\n:::\n\n\n:::{.callout-important}\nWas passiert, wenn ein Element weder Frucht noch Gemüse ist?\n:::\n\nIm obigen Code verwenden wir die Funktion `paste()` mehrmals. Es könnte Sinn machen, eine eigene Funktion definieren. Wir verwenden die Funktion `stopifnot()`, um zu prüfen, ob das Argument ein String ist. Falls dies nicht der Fall ist, wird die Funktion mit einer passenden Fehlermeldung abgebrochen. \n\n\n\n\n::: {.cell hash='functions-loops_cache/html/unnamed-chunk-17_63ea4d92898c699d4a4e9d5fc11c217a'}\n\n```{.r .cell-code}\nwhat_is <- function(x) {\n    stopifnot(is.character(x))\n\n    if (x %in% fruits) {\n        paste(x, \"is a fruit\") |> print()\n    } else if (x %in% vegetables) {\n        paste(x, \"is a vegetable\") |> print()\n    } else {\n        paste(x, \"is neither fruit nor vegetable\") |> print()\n    }\n}\n```\n:::\n\n::: {.cell hash='functions-loops_cache/html/unnamed-chunk-18_df25d5e9d68af26eb534e3c53dc5d1f4'}\n\n```{.r .cell-code}\nfor (food in foods) {\n    what_is(food)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"cucumber is a vegetable\"\n[1] \"carrot is a vegetable\"\n[1] \"orange is a fruit\"\n[1] \"cherry is a fruit\"\n[1] \"banana is a fruit\"\n[1] \"tomato is a vegetable\"\n```\n:::\n:::\n\n\n\n\n\n## Alternativen zu `for`-Loops\n\nEs gibt in R mehrere Möglichkeiten, um über Vektoren oder Listen zu iterieren, ohne dabei explizite  `for`-Loops zu schreiben. Dies hat den Vorteil, dass der Code kürzer und übersichtlicher wird. \n\n\n### `lapply` und `sapply`\n\n`lapply` und `sapply` sind zwei Funktionen, welche über Listen iterieren. `lapply` und `sapply` sind sehr ähnlich. `lapply` gibt eine Liste zurück, während `sapply` eine Liste retournieren kann.\n\n\nAls Beispiel wollen wir jedes Element eines Vektors verdoppeln (dies kann in R auch einfacher gemacht werden, aber dies ist nur ein Übungsbeispiel). \n\n\n::: {.cell hash='functions-loops_cache/html/unnamed-chunk-19_b646d3814c6320d5211a11191cbd8f56'}\n\n```{.r .cell-code}\nnumbers <- c(1, 2, 3, 4, 5)\n```\n:::\n\n\n\nMit `for` können wir dies wie folgt tun.\n\n\n::: {.cell hash='functions-loops_cache/html/unnamed-chunk-20_7f256fc6f353fd241330cc08eb73e954'}\n\n```{.r .cell-code}\nfor (number in numbers) {\n    print(number * 2)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n[1] 4\n[1] 6\n[1] 8\n[1] 10\n```\n:::\n:::\n\n\n\nMit `lapply` und `sapply` haben wir zwei Möglichkeiten. Wir können entweder eine anonyme Funktion definieren, oder wir können eine Funktion zuerst definieren, und dann verwenden. \n\n`\\(x) x * 2` definiert eine sogenannte anonyme Funktion. Diese Funktion nimmt ein Argument `x` und multipliziert es mit 2, erhält aber keinen eigenen Namen. Folglich können wir diese Funktion nicht wiederverwenden. \n\n\n::: {.cell hash='functions-loops_cache/html/unnamed-chunk-21_2d1dc4fe2115158698e631525a530732'}\n\n```{.r .cell-code}\nlapply(numbers, \\(x) x * 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 2\n\n[[2]]\n[1] 4\n\n[[3]]\n[1] 6\n\n[[4]]\n[1] 8\n\n[[5]]\n[1] 10\n```\n:::\n:::\n\n\n\nMit einer Funktion, die wir zuerst definieren, sieht unser Beispiel so aus.\n\n\n::: {.cell hash='functions-loops_cache/html/unnamed-chunk-22_3f6b9faebc32112c77f3025bd9d86182'}\n\n```{.r .cell-code}\ndouble <- function(x) {\n    x * 2\n}\n```\n:::\n\n::: {.cell hash='functions-loops_cache/html/unnamed-chunk-23_354f6368aa81cc80d250c978a4d69fbc'}\n\n```{.r .cell-code}\nlapply(numbers, double)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 2\n\n[[2]]\n[1] 4\n\n[[3]]\n[1] 6\n\n[[4]]\n[1] 8\n\n[[5]]\n[1] 10\n```\n:::\n:::\n\n::: {.cell hash='functions-loops_cache/html/unnamed-chunk-24_5595303223af5534a6581b0c37dea1bc'}\n\n```{.r .cell-code}\nsapply(numbers, double)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  4  6  8 10\n```\n:::\n:::\n\n\n\n\n\n### `map`\nEine weitere Möglichkeit, über Listen zu iterieren, ist die Funktion `map`. `map` ist eine Funktion aus dem Paket `purrr` (wird automatisch geladen, wenn `tidyverse` geladen wird). `map` gibt immer eine Liste zurück. \n\n\n::: {.cell hash='functions-loops_cache/html/unnamed-chunk-25_587f90abcf60ca912ede2ff6f4e7f697'}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n::: {.cell hash='functions-loops_cache/html/unnamed-chunk-26_230d4b7a2d41fe50988fe648ceacc9fc'}\n\n```{.r .cell-code}\nnumbers |> map(double)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 2\n\n[[2]]\n[1] 4\n\n[[3]]\n[1] 6\n\n[[4]]\n[1] 8\n\n[[5]]\n[1] 10\n```\n:::\n:::\n\n\nWenn wir als Output einen Vektor haben wollen, müssen wir die Funktion `unlist()` verwenden. \n\n\n\n::: {.cell hash='functions-loops_cache/html/unnamed-chunk-27_8cd2b539e56aae5ef39f3117ed679989'}\n\n```{.r .cell-code}\nnumbers |> map(double) |> unlist()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  4  6  8 10\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}